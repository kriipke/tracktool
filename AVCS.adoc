= Audio Version Control (A-VCS) — Spec v1.0
:toc:
:toclevels: 3
:icons: font
:sectanchors:
:sectnums:

A clean, producer-friendly “audio VCS” from *writing → post → mastering*. It keeps the exact naming logic, makes edge-cases explicit, and adds just enough structure (folders, manifests, symlinks) so collaborators and future-you can glance and know what’s what.

== 1) Vocabulary & Tokens

* *TRACK* — constant, all-caps, words separated by `_` only: `\[A-Z0-9_]+`
* *T1* — 12-hour, zero-padded 4-digit time, plus `A|P` (AM/PM): `HHMM\[A|P]`
  \*\* Examples: `0007A`, `0942P`, `1200A`, `1200P`
  \*\* Edge rules: 12:00–12:59 AM ⇒ `1200A…`; 12:00–12:59 PM ⇒ `1200P…`
* *T2* — a second time token, same format, used for post-production stem bounces
* *STEM* — controlled vocabulary (suggested): `BASS|DRUMS|KICK|SNARE|PERC|VOCALS|BGV|SYNTH|PIANO|GTR|FX|PAD|LEAD|SUB|ROOM|BUS_<NAME>`
  \*\* Extend if needed but keep to `\[A-Z0-9_]+`.
* *IDX* — mastering index: integer `1..n` or the literal `FINAL`
* *EXT* — file extension: `.als`, `.wav`, `.mp3`

== 2) Naming Grammar (Formal)

Write-phase snapshots (Ableton save + bounces):

[source,text]
----
<TRACK>-<T1>.als
<TRACK>-<T1>.wav
<TRACK>-<T1>.mp3
----

Post-production stems (Pro Tools, etc):

[source,text]
----
<TRACK>-<T1>-<T2>-<STEM>.wav
----

Unmastered stereo (render from post session using that stem set):

[source,text]
----
<TRACK>-<T1>-<T2>-[unmastered].wav
----

Master candidates (in-house):

[source,text]
----
<TRACK>-<T1>-<T2>-<IDX>.wav         ; IDX = 1,2,3,...
<TRACK>-<T1>-<T2>-FINAL.wav         ; duplicate of the chosen IDX
----

=== Regex (for validators/automation)

* Write ALS: `^([A-Z0-9_]+)-([0-1][0-9][0-5][0-9][AP])\.als$`
* Write WAV/MP3: `^([A-Z0-9_]+)-([0-1][0-9][0-5][0-9][AP])\.(wav|mp3)$`
* Stem WAV: `^([A-Z0-9_]+)-([0-1][0-9][0-5][0-9][AP])-([0-1][0-9][0-5][0-9][AP])-([A-Z0-9_]+)\.wav$`
* Unmastered: `^([A-Z0-9_]+)-([0-1][0-9][0-5][0-9][AP])-([0-1][0-9][0-5][0-9][AP])-\[unmastered\]\.wav$`
* Master: `^([A-Z0-9_]+)-([0-1][0-9][0-5][0-9][AP])-([0-1][0-9][0-5][0-9][AP])-(FINAL|[1-9][0-9]*)\.wav$`

== 3) Canonical Folder Layout

[source,text]
----
PROJECTS/
└── <TRACK>/
├── ableton/                 # .als snapshots + primary bounces
│   ├── <TRACK>-<T1>.als
│   ├── <TRACK>-<T1>.wav
│   └── <TRACK>-<T1>.mp3
├── stems/                   # grouped per (T1,T2) bounce set
│   └── <T1>-<T2>/
│       ├── <TRACK>-<T1>-<T2>-BASS.wav
│       └── <TRACK>-<T1>-<T2>-DRUMS.wav
├── post/                    # DAW session for post (e.g., PTX)
│   └── <T1>-<T2>/
│       ├── session.ptx
│       └── prints/          # (optional) printed buses, refs
├── mixes/
│   ├── <TRACK>-<T1>-<T2>-\[unmastered].wav
│   └── refs/                # comparators / references
├── masters/
│   ├── <TRACK>-<T1>-<T2>-1.wav
│   ├── <TRACK>-<T1>-<T2>-2.wav
│   └── <TRACK>-<T1>-<T2>-FINAL.wav
├── manifests/               # JSON/YAML entries per version event
│   └── <ISO8601>\_<event>.json
└── symlinks/                # fast pointers
├── LATEST\_ALS -> ../ableton/<TRACK>-<T1>.als
├── LATEST\_BOUNCE -> ../ableton/<TRACK>-<T1>.wav
├── LATEST\_STEMS -> ../stems/<T1>-<T2>/
├── LATEST\_UNMASTERED -> ../mixes/<TRACK>-<T1>-<T2>-\[unmastered].wav
└── FINAL -> ../masters/<TRACK>-<T1>-<T2>-FINAL.wav
----

[quote]
Rationale: folders are chronological but also *semantic*. You can zip `masters/` for delivery without dragging along DAW sessions; stems and post live cleanly apart.

== 4) Workflow (State Machine)

. *Write (Ableton)*
.. On every meaningful save: save `.als` using `<TRACK>-<T1>.als`.
.. Render a full-length WAV with *exactly* the same base name and make a 320 kbps MP3 (for quick A/B and mobile checks).
.. Update `symlinks/LATEST_ALS` and `symlinks/LATEST_BOUNCE`.

. *Post (Pro Tools or similar)*
.. Stem out from the chosen Ableton snapshot `<T1>` and name stems with a fresh `<T2>`:
`<TRACK>-<T1>-<T2>-<STEM>.wav` into `stems/<T1>-<T2>/`.
.. Create a post session folder `post/<T1>-<T2>/` and work from those stems.
.. When ready, print the *unmastered* stereo to `mixes/<TRACK>-<T1>-<T2>-[unmastered].wav`.
.. Update `symlinks/LATEST_STEMS` and `symlinks/LATEST_UNMASTERED`.

. *Mastering*
.. Each candidate render increments `IDX`:
`masters/<TRACK>-<T1>-<T2>-1.wav`, then `…-2.wav`, etc.
.. When one is chosen, duplicate to `…-FINAL.wav` and update `symlinks/FINAL`.

== 5) Examples

[source,text]
----
ABLETON save + bounces:
TRACK\_TITLE-1200A.als
TRACK\_TITLE-1200A.wav
TRACK\_TITLE-1200A.mp3

Post stems from that save at 12:30 AM:
TRACK\_TITLE-1200A-1230A-BASS.wav
TRACK\_TITLE-1200A-1230A-DRUMS.wav
TRACK\_TITLE-1200A-1230A-VOCALS.wav

Unmastered from that post:
TRACK\_TITLE-1200A-1230A-\[unmastered].wav

Mastering passes:
TRACK\_TITLE-1200A-1230A-1.wav
TRACK\_TITLE-1200A-1230A-2.wav
TRACK\_TITLE-1200A-1230A-FINAL.wav    (if #2 chosen)
----

== 6) Manifests (Lightweight Metadata)

For every significant event (save, stem-bounce, mix, master), write a tiny JSON next to `manifests/`:

[source,json]
----
{
"event": "ableton-save",
"track": "TRACK\_TITLE",
"t1": "1200A",
"source\_file": "ableton/TRACK\_TITLE-1200A.als",
"renders": \[
{"type": "wav", "path": "ableton/TRACK\_TITLE-1200A.wav", "sr\_hz": 48000, "bit\_depth": 24, "channels": 2, "sha256": "<hash>"},
{"type": "mp3", "path": "ableton/TRACK\_TITLE-1200A.mp3", "kbps": 320, "sha256": "<hash>"}
],
"bpm": 126.0,
"key": "F#m",
"notes": "tightened kick decay; vocal comp v2",
"timestamp": "2025-08-23T23:42:19-04:00"
}
----

Create similar entries for `stems-bounce`, `unmastered-print`, `master-candidate`, `master-final`.
Hashes make remote delivery & backups verifiable.

== 7) Conventions & Guardrails

* *Characters*: `\[A-Z0-9_]` only (safe across OS and S3/object storage).
* *Sample rate/bit depth*: pick a project default (e.g., 48k/24-bit) and include in manifests for anything that deviates.
* *MP3s*: always 320 kbps CBR unless noted otherwise.
* *Time zones*: manifests should use offsetted ISO-8601; filenames stick to `A|P` (human-fast).
* *Stem vocab*: keep consistent. If routing changes, document in the manifest (`routing_map`).
* *No overwrite*: all new outputs create new files. Symlinks provide the “latest”.

== 8) Minimal Automation (Ready-to-Use Snippets)

These optional helpers reflect the spec; drop them into `PROJECTS/<TRACK>/bin/`.

=== a) Convert the latest WAV to 320k MP3 (name-matched)

[source,bash]
----
#!/usr/bin/env bash
set -euo pipefail
wav="\$1"  # e.g., ableton/TRACK\_TITLE-1200A.wav
mp3="\${wav%.wav}.mp3"
ffmpeg -y -i "\$wav" -codec\:a libmp3lame -b\:a 320k "\$mp3"
----

=== b) Make/refresh symlinks

[source,bash]
----
#!/usr/bin/env bash
set -euo pipefail
ln -sfn "../ableton/\$(basename "\$1")" "symlinks/LATEST\_BOUNCE"
----

=== c) Finalize a master (duplicate chosen IDX → FINAL)

[source,bash]
----
#!/usr/bin/env bash
set -euo pipefail
cand="\$1"  # masters/TRACK\_TITLE-1200A-1255A-3.wav

# Replace trailing -<n>.wav with -FINAL.wav

final="\${cand%-\[0-9]\*.wav}-FINAL.wav"
cp -p "\$cand" "\$final"
ln -sfn "../masters/\$(basename "\$final")" "symlinks/FINAL"
----

=== d) Quick validators (bash + `grep -E`)

[source,bash]
----
is_write()   { echo "\$1" | grep -Eq '^\[A-Z0-9\_]+-\[0-1]\[0-9]\[0-5]\[0-9]\[AP].(als|wav|mp3)\$'; }
is_stem()    { echo "\$1" | grep -Eq '^\[A-Z0-9\_]+-\[0-1]\[0-9]\[0-5]\[0-9]\[AP]-\[0-1]\[0-9]\[0-5]\[0-9]\[AP]-\[A-Z0-9\_]+.wav\$'; }
is_unmast()  { echo "\$1" | grep -Eq '^\[A-Z0-9\_]+-\[0-1]\[0-9]\[0-5]\[0-9]\[AP]-\[0-1]\[0-9]\[0-5]\[0-9]\[AP]-$unmastered$.wav\$'; }
is_master()  { echo "\$1" | grep -Eq '^\[A-Z0-9\_]+-\[0-1]\[0-9]\[0-5]\[0-9]\[AP]-\[0-1]\[0-9]\[0-5]\[0-9]\[AP]-(FINAL|\[1-9]\[0-9]\*).wav\$'; }
-------------------------------------------------------------------------------------------------------------------------------------------------

=== e) Manifests (tiny helper)

* Add a post-render step that computes `sha256sum` and writes the JSON (schema above).
* If you prefer YAML, mirror the same fields.

== 9) Git, Git LFS & Backups (Practical Guidance)

* *Git* for manifests, session files *metadata*, docs, scripts, and symlinks.
* *Git LFS* for `.wav`, `.mp3`, `.als` if you want them in the repo; or keep audio in object storage (S3/GDrive) and store only manifests + checksums + paths.

[source,gitconfig]

# .gitattributes

*.wav filter=lfs diff=lfs merge=lfs -text
*.mp3 filter=lfs diff=lfs merge=lfs -text
*.als filter=lfs diff=lfs merge=lfs -text
------------------------------------------

* *Remote offsite*: `rsync`/`rclone` the project folder (or only `masters/` and `mixes/`). Manifests make integrity checks trivial (`sha256`).

== 10) Team Handoff & Delivery

* Send a single folder: `masters/` (all candidates + FINAL) and `mixes/` if needed.
* Include `manifests/` and optionally `stems/<T1>-<T2>/` when a remix or alternate mastering is planned.
* The `FINAL` symlink and `…-FINAL.wav` remove ambiguity about *the* chosen master.

== Optional Next Step

If desired, a small CLI (`tracktool`) can:

* Validate names against the regexes,
* Write manifests automatically (incl. hashes, durations),
* Maintain the symlinks,
* Convert WAV→MP3 via `ffmpeg`,
* Pack “delivery zips” (e.g., `masters+final.zip`).

*Tell me your preferred language (Go or Python) and whether you want Git LFS or S3 for audio storage, and I’ll generate it.*

